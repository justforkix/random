   
# Git configuration:
1. /etc/gitconfig (--system)
2. ~/.gitconfig (--global)
3. .git/config

$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
$ git config --global core.editor emacs
$ git config --global merge.tool emerge

# Check settings
$ git config --list

# Check specific value
$ git config user.name

# Initialize a repository in an existing directory
$ git init

# Clone an existing repository
$ git clone git://github.com/test/proj.git
$ git clone git://github.com/test/proj.git myproj

# Checking the status of files
$ git status

# Tracking new files or staging modified files
$ git add README

Git stages a file exactly as it is when you run the git add command. If you commit now, the version of your file  as it was when you last ran the git add
command is how it will go into the commit, not the version of the file as it looks in your working directory when you run git commit. If you modify a file after
you run git add, you have to run git add again to stage the latest version of the file.

# Ignoring files
The rules for the patterns you can put in the .gitignore file are as follows:

Blank lines or lines starting with # are ignored.
Standard glob patterns work.
You can end patterns with a forward slash (/) to specify a directory.
You can negate a pattern by starting it with an exclamation point (!)

# Viewing staged and unstaged changes
$ git diff - The changes you’ve made in your working directory that you haven’t yet staged.
$ git diff --cached - The changes see you’ve staged that will go into your next commit.

# Commiting changes
$ git commit -m "fixed bug"

# Skipping the staging area. Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add.
$ git commit -a -m "fixed bug"

# Removing files
$ git rm log/\*.log (Note the backslash (\) in front of the * glob pattern)
$ git rm -f readme.txt (If you modified the file and added it to the index already)
$ git rm --cached readme.txt (To keep the file in your working tree but remove it from your staging area)

# Moving files
$ git mv file_from file_to

# Viewing commit history
$git log --pretty=format:"%h - %an, %ar : %s" --graph --name-status -5 --grep "first commit" --committer "justforkix" --since=3.weeks

# Changing your last commit (If you forgot to stage changes to a file you wanted to add to this commit or edit the message)
$ git commit --amend

# Unstage a staged file
$ git reset HEAD readme.txt

# Unmodify a modified file in the workspace
$ git checkout -- readme.txt

# Discard unstaged changes in git
$ git checkout -- . (for all unstaged files)
$ git checkout path/to/file/to/revert

# Show remote repositories
$ git remote -v

# Adding remote repositories
$ git remote add [shortname] [url] 
$ git remote add project git://github.com/test/proj.git

# Fetching and pulling from remotes
$ git fetch [remote-name] (fetches any new work that has been pushed to that server since you cloned or last fetched from it. It doesn't automatically merge)
$ git pull [remote-name] (If you have a branch set up to track a remote branch this automatically fetches and then merges a remote branch into your current branch)

# Pushing to remotes
$ git push [remote-name] [branch-name]
$ git push origin master

# Inspecting a remote
$ git remote show [remote-name]
$ git remote show origin

# Renaming remotes
$ git remote rename from to

# Removing a remote
$ git remote rm project

# Listing tags
$ git tag
$ git tag -l 'v1.4.2.*'

# Creating tags
$ git tag -a v1.4 -m 'my version 1.4' (Annotated tag)
$ git tag -s v1.5 -m 'my signed 1.5 tag' (Signed and annotated tag)

# Verify signed tags
$ git tag -v [tag-name]
$ git tag -v v1.4.2.1

# Lightweight tag
$ git tag v1.4-lw

A lightweight tag is very much like a branch that doesn’t change — it’s just a pointer to a specific commit. Annotated tags, however, are stored as full objects
in the Git database. They’re checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy
Guard (GPG).

# Tagging older commits
$ git tag -a v1.2 -m 'version 1.2' 9fceb02

# View tag data
$ git show v1.4

# Sharing tags
$ git push origin v1.5
$ git push origin --tags

# Autocompletion
source ~/git-completion.bash 

# Git aliases
$ git config --global alias.st status
$ git config --global alias.unstage 'reset HEAD --'
$ git config --global alias.last 'log -1 HEAD'
$ git config --global alias.visual '!gitk' (run external command)

Staging the files checksums each one (the SHA-1 hash), stores that version of the file in the Git repository (Git refers to them as
blobs), and adds that checksum to the staging area. Running git commit checksums all project directories and stores them as tree objects in the Git
repository. Git then creates a commit object that has the metadata and a pointer to the root project tree object so it can re-create that snapshot when needed.

A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you initially make commits, you’re
given a master branch that points to the last commit you made. Every time you commit, it moves forward automatically.

# Create a branch (This creates a new pointer at the same commit you’re currently on)
$ git branch testing (does not switch to that branch)

How does Git know what branch you’re currently on? It keeps a special pointer called HEAD. 

# Switch to a branch
$ git checkout -b testing (create a new branch and switch to it)
$ git checkout testing (This moves HEAD to point to the testing branch)

Git resets your working directory to look like the snapshot of the commit that the branch you check out points to. It adds, removes, and modifies files
automatically to make sure your working copy is what the branch looked like on your last commit to it.

# Merging branches (hotfix to master) 
$ git checkout master
$ git merge hotfix

# Deleting branch
$ git branch -d hotfix

# Invoke merge tool
$ git mergetool

# List branches with commit info
$ git branch -v
$ git branch --merged (list only branches merged into the current branch)
$ git branch --no-merged (list only branches that haven't yet been merged into the current branch)

# Force delete an unmerged branch
$ git branch -D testing

Remote branches are references to the state of branches on your remote repositories. They’re local branches that you can’t move; they’re moved automatically
whenever you do any network communication. They take the form (remote)/(branch). If you do some work on your local master branch, and, in the meantime, someone
else pushes to git.ourcompany.com and updates its master branch, then your histories move forward differently. Also, as long as you stay out of contact with
your origin server, your origin/master pointer doesn’t move. 

To synchronize your work, you run a git fetch origin command. This command looks up which server
origin is (in this case, it’s git.ourcompany.com), fetches any data from it that you don’t yet have, and updates your local database, moving your origin/master
pointer to its new, more up-to-date position.

# Synchronize remote references 
$ git fetch origin

# Push a branch to a remote for sharing
$ git push (remote) (branch)
$ git push origin serverfix
$ git push origin serverfix:awesomebranch (name the remote branch differently)

It’s important to note that when you do a fetch that brings down new remote branches, you don’t automatically have local, editable copies of them. In other
words, in this case, you don’t have a new serverfix branch — you only have an origin/serverfix pointer that you can’t modify.

# Merge a remote branch into the current branch
$ git merge origin/serverfix

# Create a local branch based off a remote branch to work on
$ git checkout -b serverfix origin/serverfix

Checking out a local branch from a remote branch automatically creates what is called a tracking branch. Tracking branches are local branches that have a direct
relationship to a remote branch. If you’re on a tracking branch and type git push, Git automatically knows which server and branch to push to. Also, running git
pull while on one of these branches fetches all the remote references and then automatically merges in the corresponding remote branch.

# Tracking branch (Automatically push, fetch and pull from and to origin/serverfix)
$ git checkout --track origin/serverfix
$ git checkout -b sf origin/serverfix 

# Delete a remote branch
$ git push [remotename] :[branch]
$ git push origin :serverfix

Rebasing works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), getting the diff introduced by each
commit of the branch you’re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and
finally applying each change in turn.

# Rebasing (Often, you’ll do this to make sure your commits apply cleanly on a remote branch)
$ git checkout experiment
$ git rebase master (Then go back to the master branch and do a fast-forward merge)
$ git rebase [basebranch] [topicbranch] (rebase topic branch onto the master branch without having to check it out first)
$ git rebase master server
$ git rebase --onto master server client (Take changes on the client that aren't on the server and replay them on master branch. Here master<--server<--client)

Do not rebase commits that you have pushed to a public repository. If you treat rebasing as a way to clean up and work with commits before you push them, and if
you only rebase commits that have never been available publicly, then you’ll be fine.

# List files in a commit
$ git diff-tree --no-commit-id --name-status -r 54adeb

# Merge files from another branch
$ git checkout merge_to_branch
$ git checkout merge_from_branch  src/dir1/ src/dir2/ .gitignore 

# Checkout branch at a specific commit
$ git checkout -b development  a9c146a

# Unstage all files
$ git reset HEAD

# Revert from published commits to an older commit
$ it revert --no-commit 0766c053..HEAD (the hash is the commit to revert to) 